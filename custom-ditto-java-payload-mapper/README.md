# Custom Ditto Java Payload Mapper

This example module contains an example for a Java based 
[MessageMapper](https://www.eclipse.dev/ditto/connectivity-mapping.html#custom-java-based-implementation) for Ditto's
[connectivity payload mapping](https://www.eclipse.dev/ditto/connectivity-mapping.html).

Eclipse Ditto is able to:
* map arbitrary (external) **inbound payloads** to [Ditto Protocol](https://www.eclipse.dev/ditto/protocol-overview.html) 
  messages which Ditto can understand
* map **outbound** [Ditto Protocol](https://www.eclipse.dev/ditto/protocol-overview.html) based messages to arbitrary
  (external) **outbound payloads**

## Example use case

A common format for sending data is [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview) 
(aka "Protobuf") by Google.

Using those, it is possible to define in a `.proto` file containing the domain specific messages from which language 
specific files (e.g. source files) are generated by the "protocol buffer compiler" of the target language.

For Java, for example, there is a 
[protobuf compiler](https://developers.google.com/protocol-buffers/docs/reference/java-generated#invocation) generating
Java source files which the Java compiler then can compile and e.g. package via Maven into a `.jar` file.

In this example, we want to provide a Java based Protobuf MessageMapper for Ditto which can be added to Ditto's classpath
in order to be able to map e.g. inbound domain specific messages to Ditto understandable "Ditto Protocol".

## Example domain specific types

The `.proto` file is part of the example: [octopus.proto](src/main/proto/octopus.proto)

This includes a domain specific message 
* for messages the device sends: `OctopusOutboundMessage`
* for messages the device receives: `OctopusInboundMessage`

An IoT application would for example generate C++ code based on the [octopus.proto](src/main/proto/octopus.proto) file
and e.g. send `OctopusOutboundMessage` whenever e.g. the environmental sensors detect a change in the measured sensor 
readings.

By receiving "configuration" changes included in a `OctopusInboundMessage` the device might adjust its frequency of how
often it sends sensor reading into the cloud, or an "action" on the device could be invoked.

## Implementing the custom MessageMapper

The example contains the [OctopusProtobufMessageMapper](src/main/java/org/eclipse/ditto/examples/custompayloadmapper/octopus/OctopusProtobufMessageMapper.java)
which extends the `AbstractMessageMapper` class contained in `<artifactId>ditto-connectivity-service</artifactId>`.

It configures the mapper alias `"CustomOctopusProtobuf"` with which it will be used in Ditto managed connections.

This example mapper simply uses the generated (generated by the Maven build process of this example) Java code for 
parsing `OctopusOutboundMessage`s from `ExternalMessage`s, converting them to DittoProtocol `Adaptable`s.

And it creates `OctopusInboundMessage`s from DittoProtocol `Adaptable`s and wraps them into `ExternalMessages`s
in their binary protobuf representation.

## Configuring Ditto connectivity to load our custom mapper

The example contains a [connectivity-extension.conf](connectivity-extension.conf) file in which the custom payload 
mapper is configured.  
This file is simply mounted into the started `ditto-connectivity` Docker container via the 
[docker-compose.yml](docker-compose.yml) of this example.

The config file simply adds the new custom mapper to the existing list of mappers (using `+=`): 
```hocon
ditto {
  extensions {
    message-mapper-provider.extension-config {
      # adds our custom MessageMapper to the already existing list of "message-mappers":
      message-mappers += "org.eclipse.ditto.examples.custompayloadmapper.octopus.OctopusProtobufMessageMapper"
    }
  }
}
```

## Building the artifacts

For this example, we require two `.jar` files which we want to add to the Ditto connectivity service's classpath:
* `custom-ditto-java-payload-mapper-1.0-SNAPSHOT.jar` (the `.jar` created within this maven module)
* `protobuf-java-3.21.6.jar` (the dependency to protobuf)

## Enhancing the docker image with the custom mapper

After we have built+downloaded the artifacts, we want to add them to the classpath of ditto-connectivity service.

In order to do that, we have 2 options:
1. Build an own Docker image in which we reference Ditto's `ditto-connectivity` image as parent
2. Start the plain `ditto-connectivity` image and add a volume mount containing the 2 artifacts

For this example we choose the second option and just mount the required `.jar` files and the `.conf` file configuring
the additional payload mappers:

```yaml
  connectivity:
    image: docker.io/eclipse/ditto-connectivity:${DITTO_VERSION:-latest}
    ...
    volumes:
      - ./connectivity-extension.conf:/opt/ditto/connectivity-extension.conf
      - ./logback.xml:/opt/ditto/logback.xml
      - ./target/custom-ditto-java-payload-mapper-1.0-SNAPSHOT.jar:/opt/ditto/extensions/custom-ditto-java-payload-mapper-1.0-SNAPSHOT.jar
      - ./target/dependency:/opt/ditto/extensions
```

## Executing the example

This should be as easy as doing:
```bash
mvn clean package

docker-compose up -d
```

Ensure that the Ditto services are started and healthy:
```bash
docker-compose ps

curl http://localhost:8080/status/health
```

Create a new connection to `mqtt.eclipseprojects.io` using the custom payload mapper:
```bash
curl -i -X POST -u devops:foobar -H 'Content-Type: application/json' --data '{
  "connectionType": "mqtt",
  "connectionStatus": "open",
  "uri": "ssl://mqtt.eclipseprojects.io:8883",
  "failoverEnabled": true,
  "sources": [
    {
      "addresses": [
        "ditto-example-custom-payload-mapper/source"
      ],
      "authorizationContext": [
        "pre:ditto"
      ],
      "headerMapping": {
      },
      "qos": 0,
      "replyTarget": {
        "enabled": false,
        "expectedResponseTypes": [
          "response",
          "error"
        ]
      },
      "payloadMapping": ["CustomOctopusProtobuf"]
    }
  ],
  "targets": [
    {
      "address": "ditto-example-custom-payload-mapper/target",
      "authorizationContext": [
        "pre:ditto"
      ],
      "topics": [
        "_/_/things/twin/events",
        "_/_/things/live/messages"
      ],
      "headerMapping": {
      },
      "qos": 0,
      "payloadMapping": ["CustomOctopusProtobuf"]
    }
  ]
}' http://localhost:8080/api/2/connections
```

Create a thing via HTTP:
```bash
curl -i -X PUT -H 'x-ditto-pre-authenticated: pre:ditto' -H 'Content-Type: application/json' --data '{
}' http://localhost:8080/api/2/things/org.eclipse.ditto:thing-1
```

Verify that it is empty:
```bash
curl -i -H 'x-ditto-pre-authenticated: pre:ditto' http://localhost:8080/api/2/things/org.eclipse.ditto:thing-1
```

Use a MQTT cli for performing the next command, in this example we use 
[HiveMQ'S mqtt-cli](https://www.hivemq.com/blog/mqtt-cli/).

Send a profobuf encoded message (located in file [example-protobuf-msg](example-protobuf-msg)) to modify the 
existing thing:
```bash
mqtt pub -h mqtt.eclipseprojects.io -p 8883 -s -t ditto-example-custom-payload-mapper/source --message-file example-protobuf-msg
```

Verify that the thing was updated in Ditto:
```bash
curl -i -H 'x-ditto-pre-authenticated: pre:ditto' http://localhost:8080/api/2/things/org.eclipse.ditto:thing-1
```

That should return:
```json
{
  "thingId": "org.eclipse.ditto:thing-1",
  "policyId": "org.eclipse.ditto:thing-1",
  "features": {
    "voltage": {
      "properties": {
        "value": 3.299999952316284
      }
    },
    "temperature": {
      "properties": {
        "value": 24.2
      }
    },
    "humidity": {
      "properties": {
        "value": 48.43
      }
    },
    "pressure": {
      "properties": {
        "value": 1000.2
      }
    },
    "gas_resistance": {
      "properties": {
        "value": 0.32
      }
    },
    "altitude": {
      "properties": {
        "value": 412.3
      }
    }
  }
}
```

## Congratulations

At this point, you have a functioning, custom payload mapper included into your Ditto installation.
